
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Copyright 2022 GIP SmartMercial GmbH, Germany
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -



# OS library

# default minimum value for ulimit -n, see also f_check_os_settings
MIN_ULIMIT_OPEN_FILES="1024"
GIPGROUP=gipgroup

#  Eine Zeile in die Crontab eintragen
#
#  Eingabeparameter:
#+  1 = Zeile, die eingetragen werden soll (muss im crontab-Format sein)
#
f_add_crontab_entry () {
    local CRONTAB_LINE="${1}"

    #  Fuer grep muessen einige Sonderzeichen escaped werden...
    local ESCAPED_STRING=$(echo "${CRONTAB_LINE}" | ${VOLATILE_SED} -e "s+*+\\\*+g" -e "s+&+\\\&+g")
    
    if [[ "x${CRONTAB_LINE}" == "x" ]]; then
  err_msg "f_add_crontab_entry: unable to work without input."
  return ${EX_PARAMETER}
    fi

    #  Es ist unklar, wo genau die Dateien mit dem Inhalt der crontab
    #+ abgespeichert werden. Deswegen folgendes Konzept:
    #o 'crontab -l' zeigt die aktuelle crontab an
    #o 'crontab <filename>' richtet eine neue crontab ein
    
    #  (1) crontab -l
    #+ Es kann drei Zeilen am Anfang geben, oder auch nicht.
    #+ Diese sind zu entfernen...
    case $(crontab -l 2>/dev/null | ${VOLATILE_GREP} -c "DO NOT EDIT THIS FILE") in
  0)  crontab -l 2>/dev/null | ${VOLATILE_GREP} -v "${ESCAPED_STRING}" > "${TMP_FILE}"
      ;;
  1)  #  ... Header abschneiden
      crontab -l 2>/dev/null | tail -n +4 | ${VOLATILE_GREP} -v "${ESCAPED_STRING}" > "${TMP_FILE}"
      ;;
  *)  err_msg "f_add_crontab_entry: Unexpected number of lines 'DO NOT EDIT THIS FILE'"
      return
      ;;
    esac    
    
    #  (2) crontab <filename>
    echo "${CRONTAB_LINE}" >> "${TMP_FILE}"
    crontab "${TMP_FILE}"
    ${VOLATILE_RM} -f "${TMP_FILE}"
}


#Bestimmt die Anzahl der offenen File Diskriptoren eines Benutzers
f_get_nr_open_files() {
  INT_OPEN_FILES=0
  local ret_val=0
  
  case ${INSTALLATION_PLATFORM} in
    sles|rhel|oracle|debian|ubuntu|centos)
      INT_OPEN_FILES=$(lsof -u $UID | grep -c $USER)
      ret_val=$?
       ;;
    solaris)
      INT_OPEN_FILES=$(pfiles /proc/* 2>/dev/null | grep -c $UID)
      ret_val=$?
      ;;
  esac
  echo ${INT_OPEN_FILES} 
  
  return ${ret_val}
}

f_configure_limits () {
    local ret_val=0
    local USER_PROCESSES="16383"
    local SOFT_FILES="32767"
    local HARD_FILES="65535"
    
    echo -e "\n* Configuring system limits"

    case ${INSTALLATION_PLATFORM} in
  sles|rhel|oracle|debian|ubuntu|centos)
      local FILE_TO_EDIT="/etc/security/limits.conf"
      exit_if_not_exists "${FILE_TO_EDIT}"
      backup_file "${FILE_TO_EDIT}"

      #  delete existing entries
      ${VOLATILE_CP} -p -f "${FILE_TO_EDIT}" "${TMP_FILE}"
      ${VOLATILE_AWK} '! ($1 == "*" && ( $3 == "nproc" || $3 == "nofile" ) ) { print $0 }' "${FILE_TO_EDIT}" > "${TMP_FILE}"
      ${VOLATILE_MV} "${TMP_FILE}" "${FILE_TO_EDIT}"
      if [[ -d "/etc/security/limits.d" ]]; then
        ${VOLATILE_RM} -f /etc/security/limits.d/*
      fi

      #  add new entries
      local NUMBER_OF_LINES=$(${VOLATILE_AWK} 'END {print NR}' "${FILE_TO_EDIT}")
      ${VOLATILE_CAT} > "${TMP_FILE}" << A_HERE_DOCUMENT
$((NUMBER_OF_LINES - 1))a$((NUMBER_OF_LINES)),$((NUMBER_OF_LINES + 2))
> *               -       nproc           ${USER_PROCESSES}
> *               soft    nofile          ${SOFT_FILES}
> *               hard    nofile          ${HARD_FILES}
A_HERE_DOCUMENT

            #  apply the patch
      ${VOLATILE_PATCH} -l -i "${TMP_FILE}" "${FILE_TO_EDIT}"
      ${VOLATILE_RM} -f "${TMP_FILE}"
      ;;
  
  solaris)   
      local FILE_TO_EDIT="/etc/system"
      exit_if_not_exists "${FILE_TO_EDIT}"
      backup_file "${FILE_TO_EDIT}"

      #  delete existing entries
      ${VOLATILE_CP} -p -f "${FILE_TO_EDIT}" "${TMP_FILE}"
      ${VOLATILE_GREP} -v "maxuprc" "${FILE_TO_EDIT}" | ${VOLATILE_GREP} -v "rlim_fd" > "${TMP_FILE}"
      ${VOLATILE_MV} "${TMP_FILE}" "${FILE_TO_EDIT}"

      #  add new entries
      echo "set maxuprc=${USER_PROCESSES}" >> "${FILE_TO_EDIT}"
      echo "set rlim_fd_cur=${SOFT_FILES}" >> "${FILE_TO_EDIT}"
      echo "set rlim_fd_max=${HARD_FILES}" >> "${FILE_TO_EDIT}"

      STR_HINWEIS_AM_ENDE="${STR_HINWEIS_AM_ENDE} A reboot is required to activate changes to the system limits"
      ;;
  
  *) err_msg "f_configure_limits: Platform '${INSTALLATION_PLATFORM}' is not supported.";;
    esac           
    
    ret_val=$?
    return ${ret_val}
}


#Ueberpruefe OS-Parameter
f_check_os_settings () {
  if [[ -n "${1}" ]]; then
    MIN_ULIMIT_OPEN_FILES=${1}
  fi  
  local INT_MAX_OPEN_FILES=$(ulimit -n)
  if [[ ${INT_MAX_OPEN_FILES} -lt ${MIN_ULIMIT_OPEN_FILES} ]]; then
    f_exit_with_message ${EX_IOERR} "The limit for the number of open files must be greater than ${MIN_ULIMIT_OPEN_FILES}, see 'ulimit -n'"  
  else
    debug_msg "f_check_os_settings: Max Open Files: ${INT_MAX_OPEN_FILES}"
  fi
}


f_etc_initd_files() {
  local NAME=${1}
  local SRC_FILE=${2}/initd_${NAME}_${INSTALLATION_PLATFORM}
  local UPPER_NAME=$(echo ${NAME} | awk '{ print toupper(substr($0,1,1))substr($0,2) }')
  echo -e "\n* Installing ${UPPER_NAME} in /etc/init.d"
  local PRODUCT_INSTANCE=$(printf "%03g" ${INSTANCE_NUMBER:-1})
  local ETC_INITD_FILE=${NAME}_${PRODUCT_INSTANCE}
  
  #Kopieren der zu installierenden Datei und Setzen der Permissions
  install_file ${SRC_FILE} /etc/init.d/${ETC_INITD_FILE} 755
  
  case ${INSTALLATION_PLATFORM} in
    sles)
      chkconfig ${ETC_INITD_FILE} 35
      ;;
    rhel|oracle|centos)
      chkconfig ${ETC_INITD_FILE} on
      ;;
    debian)
      update-rc.d ${ETC_INITD_FILE} defaults
      ;;
    ubuntu)
      update-rc.d ${ETC_INITD_FILE} defaults
      ;;
    solaris)
      if [[ ! -L "/etc/rc3.d/S99_${ETC_INITD_FILE}" ]]; then 
        ${VOLATILE_LN} -s "../init.d/${ETC_INITD_FILE}" "/etc/rc3.d/S99_${ETC_INITD_FILE}";
      fi
      ;;
    *) err_msg "f_etc_initd_files ${NAME}: Platform '${INSTALLATION_PLATFORM}' is not supported.";;
  esac
  
  #Ersetzungen in der installierten Datei 
  f_replace_in_file "/etc/init.d/${ETC_INITD_FILE}" "${@:3}"
}

f_etc_systemd_files() {
  local NAME=${1}
  local SRC_FILE=${2}/systemd_${NAME}
  local UPPER_NAME=$(echo ${NAME} | awk '{ print toupper(substr($0,1,1))substr($0,2) }')
  echo -e "\n* Installing ${UPPER_NAME} in /etc/systemd/system"
  local PRODUCT_INSTANCE=$(printf "%03g" ${INSTANCE_NUMBER:-1})
  local ETC_SYSTEMD_FILE="${NAME}_${PRODUCT_INSTANCE}.service"
  local SYSTEMD_TARGET_DIR
  
  #Kopieren der zu installierenden Datei und Setzen der Permissions
  install_file ${SRC_FILE} /etc/systemd/system/${ETC_SYSTEMD_FILE} 644
  
  #Ersetzungen in der installierten Datei 
  f_replace_in_file "/etc/systemd/system/${ETC_SYSTEMD_FILE}" "${@:3}"
  
  systemctl enable ${ETC_SYSTEMD_FILE}
}



#Anlegen des Respawns 
# o Name des Demons (Pflicht)
# o Prefix in inittab, (default x)
# o Runlevel (default 35)
# o Demon-Aufruf (default /etc/init.d/${NAME}_${PRODUCT_INSTANCE} demon)
f_etc_respawn () {
  local NAME=${1}
  local PREFIX=${2:-x}
  local RUNLEVEL=${3:-35}
  local DEMON="${4:-/etc/init.d/${NAME}_${PRODUCT_INSTANCE} demon}";
  echo -e "\n* Installing and starting respawn of ${NAME}"
  #TODO eigentlich ist alles noch viel komplizierter, da alle Systeme auf systemd wechseln werden
  #-> Versionen müssten geprüft werden.
  case ${INSTALLATION_PLATFORM} in
    sles)
      f_etc_respawn_inittab ${PREFIX} "${DEMON}" ${RUNLEVEL}
      ;;
    rhel|oracle|centos)
      f_etc_respawn_upstart "${NAME}_${PRODUCT_INSTANCE}" "${DEMON}" ${RUNLEVEL}
      ;;
    debian)
      f_etc_respawn_inittab ${PREFIX} "${DEMON}" ${RUNLEVEL}
      ;;
    ubuntu)
      f_etc_respawn_inittab ${PREFIX} "${DEMON}" ${RUNLEVEL}
      ;;
        solaris)
      echo -e "\n***** ERROR: Respawn is not implemented for solaris. Configure manually! *****"
      ;;
    *) err_msg "f_etc_respawn ${NAME}: Platform '${INSTALLATION_PLATFORM}' is not supported.";;
  esac
}

f_etc_respawn_inittab () {
  local PREFIX=${1}
  local DEMON=${2}
  local RUNLEVEL=${3}
  #  Eintrag in /etc/inittab einfuegen
  #+ Demon wird mittels 'respawn' automatisch neu gestartet, falls er verstirbt
  FILE_TO_EDIT="/etc/inittab"
  exit_if_not_exists ${FILE_TO_EDIT}
  backup_file ${FILE_TO_EDIT}
  local TOKEN_INITTAB="${PREFIX}${PRODUCT_INSTANCE}"
  local RET_VAL=$(${VOLATILE_GREP} -c "^${TOKEN_INITTAB}" "${FILE_TO_EDIT}")
  case ${RET_VAL} in
    0) echo "${TOKEN_INITTAB}:${RUNLEVEL}:respawn:${DEMON}" >> ${FILE_TO_EDIT};;
    1) echo "    + nothing to do: entry '${TOKEN_INITTAB}' found in '${FILE_TO_EDIT}'";;
    *) echo -e "\n***** ERROR: Configuration in '${FILE_TO_EDIT}' is not as expected. Check manually! *****";;
  esac
  echo "    + activating changes in /etc/inittab"
  telinit q
}

f_etc_respawn_upstart () {
  local NAME=${1}
  local DEMON=${2}
  local RUNLEVEL=${3}
  FILE_TO_EDIT="/etc/init/${NAME}.conf"
  
  echo "start on stopped rc RUNLEVEL=[${RUNLEVEL}]"  > ${FILE_TO_EDIT}
  echo "stop on runlevel [!${RUNLEVEL}]"            >> ${FILE_TO_EDIT}
  echo "respawn"                                    >> ${FILE_TO_EDIT}
  echo "respawn limit 10 120"                       >> ${FILE_TO_EDIT}
  echo "exec ${DEMON}"                              >> ${FILE_TO_EDIT}
  
  echo "    + activating ${NAME} per initctl"
  initctl start ${NAME}
}


