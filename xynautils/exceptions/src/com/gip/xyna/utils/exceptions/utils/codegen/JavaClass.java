/*
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * Copyright 2022 GIP SmartMercial GmbH, Germany
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 */
package com.gip.xyna.utils.exceptions.utils.codegen;



import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Set;



public class JavaClass {

  private String fqClassName;
  private String superClassName;
  private boolean isAbstract = false;

  private Set<String> imports;
  private List<CodeBuffer> constructors;
  private List<CodeBuffer> methods;
  private List<String> membervars;
  private List<String> interfaces;
  private List<CodeBuffer> staticInitBlocks;
  private List<CodeBuffer> nestedClasses;


  public JavaClass(String path, String name) throws InvalidClassNameException {
    this.fqClassName = JavaGenUtils.transformNameForJava(path + "." + name);
    imports = new HashSet<String>();
    constructors = new ArrayList<CodeBuffer>();
    methods = new ArrayList<CodeBuffer>();
    membervars = new ArrayList<String>();
    interfaces = new ArrayList<String>();
    staticInitBlocks = new ArrayList<CodeBuffer>();
    nestedClasses = new ArrayList<CodeBuffer>();
  }


  public String getSourceCode(String department) {
    CodeBuffer cb = new CodeBuffer(department);
    cb.addLine("package " + JavaGenUtils.getPackageNameFromFQName(fqClassName)).addLB();
    for (String imp : imports) {
      cb.addLine("import " + imp);
    }
    cb.addLB();
    cb.addLine("//DO NOT CHANGE");
    cb.add("//GENERATED BY ").add(JavaClass.class.getName()).add(" ");
    cb.add(new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'").format(new Date()));
    cb.addLB();
    cb.add("public ");
    if (isAbstract) {
      cb.add("abstract ");
    }
    String simpleName = JavaGenUtils.getSimpleNameFromFQName(fqClassName);
    cb.add("class " + simpleName);
    if (superClassName != null) {
      cb.add(" extends " + superClassName);
    }
    if (interfaces.size() > 0) {
      cb.add(" implements ");
      for (String intfac : interfaces) {
        cb.addListElement(intfac);
      }
    }
    cb.add(" {").addLB(2);
    //static variables
    for (String memberVar : membervars) {
      if (memberVar.contains(" static ")) {
        cb.addLine(memberVar);
      }
    }
    if (staticInitBlocks.size() > 0) {
      cb.addLine("static {");
      for (CodeBuffer staticInitBlock : staticInitBlocks) {
        cb.addLine("{"); //lokale variablen ermöglichen
        cb.add(staticInitBlock);
        cb.addLine("}");
      }
      cb.addLine("}");
    }
    cb.addLB();

    //nonstatic variables
    for (String memberVar : membervars) {
      if (!memberVar.contains(" static ")) {
        cb.addLine(memberVar);
      }
    }
    cb.addLB();
    for (CodeBuffer constructor : constructors) {
      cb.add(constructor).addLB();
    }
    for (CodeBuffer method : methods) {
      cb.add(method).addLB();
    }
    for (CodeBuffer method : nestedClasses) {
      cb.add(method).addLB();
    }
    cb.addLB();
    cb.addLine("}");
    return cb.toString(true);
  }


  public String getFQClassName() {
    return fqClassName;
  }


  /**
   * gibt den im code zu benutztenden string für diesen import zurück. d.h. falls bereits ein import mit dem gleichen
   * simple name existiert, wird der fqname zurückgegeben, ansosnten der simplename
   * @param packageName
   * @param className
   * @return
   * @throws InvalidPackageNameException
   */
  public String addImport(String packageName, String className) throws InvalidClassNameException {
    String fqName = packageName + "." + className;
    return addImport(fqName);
  }

  /**
   * gibt true zurück, falls element vorhanden war.
   * @return
   */
  public boolean removeImport(String fqName) {
    return imports.remove(fqName);
  }

  /**
   * @see #addImport(String, String)
   * @param fqClassName
   * @return
   * @throws InvalidPackageNameException
   */
  public String addImport(String fqClassName) throws InvalidClassNameException {
    fqClassName = JavaGenUtils.transformNameForJava(fqClassName);
    String simpleName = JavaGenUtils.getSimpleNameFromFQName(fqClassName);
    if (imports.contains(fqClassName)) {
      //bereits importiert
      return simpleName;
    }
    if (JavaGenUtils.getPackageNameFromFQName(fqClassName)
                    .equals(JavaGenUtils.getPackageNameFromFQName(this.fqClassName))) {
      //kein import nötig, da gleiches package
      return simpleName;
    }
    for (String imp : imports) {
      if (imp.endsWith("." + simpleName)) {
        //anderer import hat gleichen simplename => nicht importieren
        return fqClassName;
      }
    }
    imports.add(fqClassName);
    return simpleName;
  }


  /**
   * führt addImport aus und gibt entsprechenden wert zurück
   * @see #addImport(String, String)
   * @param fqClassName
   * @return
   * @throws InvalidPackageNameException
   */
  public String addInterface(String fqClassName) throws InvalidClassNameException {
    fqClassName = addImport(fqClassName);
    interfaces.add(fqClassName);
    return fqClassName;

  }


  /**
   * führt addImport aus und gibt entsprechenden wert zurück
   * @see #addImport(String, String)
   * @param fqSuperClassName
   * @return
   * @throws InvalidPackageNameException
   */
  public String setSuperClass(String fqSuperClassName) throws InvalidClassNameException {
    this.superClassName = addImport(fqSuperClassName);
    return this.superClassName;
  }


  public String getSimpleClassName() {
    return JavaGenUtils.getSimpleNameFromFQName(fqClassName);
  }


  public void addConstructor(CodeBuffer constructor) {
    constructors.add(constructor);
  }


  public void addMethod(CodeBuffer method) {
    methods.add(method);
  }


  public void setIsAbstract(boolean b) {
    isAbstract = b;
  }


  public void addMemberVar(String m) {
    membervars.add(m);
  }


  public void addStaticInitBlock(CodeBuffer staticInit) {
    staticInitBlocks.add(staticInit);
  }
  
  public List<CodeBuffer> getMethods() {
    return methods;
  }
  
  public void addNestedClass(CodeBuffer nestedClass) {
    nestedClasses.add(nestedClass);
  }
}
