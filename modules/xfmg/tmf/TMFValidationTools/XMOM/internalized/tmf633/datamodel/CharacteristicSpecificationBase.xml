<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!--
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * Copyright 2025 Xyna GmbH, Germany
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
--><DataType xmlns="http://www.gip.com/xyna/xdev/xfractmod" BaseTypeName="OASBaseType" BaseTypePath="xmcp.oas.datatype" IsAbstract="false" Label="CharacteristicSpecificationBase" TypeName="CharacteristicSpecificationBase" TypePath="internalized.tmf633.datamodel" Version="1.8">
  <Meta>
    <IsServiceGroupOnly>false</IsServiceGroupOnly>
    <Documentation>This class defines a characteristic specification.
        </Documentation>
  </Meta>
  <Data Label="id" VariableName="id">
    <Meta>
      <Type>String</Type>
      <Documentation>Unique ID for the characteristic
        </Documentation>
    </Meta>
  </Data>
  <Data Label="configurable" VariableName="configurable">
    <Meta>
      <Type>Boolean</Type>
      <Documentation>If true, the Boolean indicates that the target Characteristic is configurable
        </Documentation>
    </Meta>
  </Data>
  <Data Label="description" VariableName="description">
    <Meta>
      <Type>String</Type>
      <Documentation>A narrative that explains the CharacteristicSpecification.
        </Documentation>
    </Meta>
  </Data>
  <Data Label="extensible" VariableName="extensible">
    <Meta>
      <Type>Boolean</Type>
      <Documentation>An indicator that specifies that the values for the characteristic can be extended by adding new values when instantiating a characteristic for a resource.
        </Documentation>
    </Meta>
  </Data>
  <Data Label="isUnique" VariableName="isUnique">
    <Meta>
      <Type>Boolean</Type>
      <Documentation>An indicator that specifies if a value is unique for the specification. Possible values are; \"unique while value is in effect\" and \"unique whether value is in effect or not\"
        </Documentation>
    </Meta>
  </Data>
  <Data Label="maxCardinality" VariableName="maxCardinality">
    <Meta>
      <Type>Long</Type>
      <Documentation>The maximum number of instances a CharacteristicValue can take on. For example, zero to five phone numbers in a group calling plan, where five is the value for the maxCardinality.
        </Documentation>
    </Meta>
  </Data>
  <Data Label="minCardinality" VariableName="minCardinality">
    <Meta>
      <Type>Long</Type>
      <Documentation>The minimum number of instances a CharacteristicValue can take on. For example, zero to five phone numbers in a group calling plan, where zero is the value for the minCardinality.
        </Documentation>
    </Meta>
  </Data>
  <Data Label="name" VariableName="name">
    <Meta>
      <Type>String</Type>
      <Documentation>A word, term, or phrase by which this characteristic specification is known and distinguished from other characteristic specifications.
        </Documentation>
    </Meta>
  </Data>
  <Data Label="regex" VariableName="regex">
    <Meta>
      <Type>String</Type>
      <Documentation>A rule or principle represented in regular expression used to derive the value of a characteristic value.
        </Documentation>
    </Meta>
  </Data>
  <Data Label="valueType" VariableName="valueType">
    <Meta>
      <Type>String</Type>
      <Documentation>A kind of value that the characteristic can take on, such as numeric, text and so forth
        </Documentation>
    </Meta>
  </Data>
  <Data Label="validFor" ReferenceName="TimePeriod" ReferencePath="internalized.tmf633.datamodel" VariableName="validFor">
    <Meta>
      <Documentation/>
    </Meta>
  </Data>
  <Data Label="@baseType" VariableName="atbaseType">
    <Meta>
      <Type>String</Type>
      <Documentation>When sub-classing, this defines the super-class
        </Documentation>
    </Meta>
  </Data>
  <Data Label="@schemaLocation" VariableName="atschemaLocation">
    <Meta>
      <Type>String</Type>
      <Documentation>A URI to a JSON-Schema file that defines additional attributes and relationships
format: uri
        </Documentation>
    </Meta>
  </Data>
  <Data Label="@type" VariableName="attype">
    <Meta>
      <Type>String</Type>
      <Documentation>When sub-classing, this defines the sub-class Extensible name
        </Documentation>
    </Meta>
  </Data>
  <Data Label="@valueSchemaLocation" VariableName="atvalueSchemaLocation">
    <Meta>
      <Type>String</Type>
      <Documentation>This (optional) field provides a link to the schema describing the value type.
        </Documentation>
    </Meta>
  </Data>
  <Service Label="CharacteristicSpecificationBase" TypeName="CharacteristicSpecificationBase">
    <Operation IsStatic="false" Label="Validate" Name="validate">
      <Input/>
      <Output>
        <Data ID="1" Label="OAS Validation Result" ReferenceName="OASValidationResult" ReferencePath="xmcp.oas.datatype" VariableName="oASValidationResult1"/>
      </Output>
      <SourceCode>
        <CodeSnippet Type="Java">
xmcp.oas.datatype.OASValidationResult result = new xmcp.oas.datatype.OASValidationResult();
result.setErrorMessages(new ArrayList&lt;String&gt;());
// validate CharacteristicSpecificationBase.id of type String
try {
    var validator_id = new com.gip.xyna.openapi.StringTypeValidator();
    validator_id.setName("id");
    validator_id.setValue(getId());
    result.getErrorMessages().addAll(validator_id.checkValid());
} catch (Exception e) {
    result.getErrorMessages().add("Error: could not validate CharacteristicSpecificationBase.id");
}

// validate CharacteristicSpecificationBase.configurable of type Boolean
try {
    var validator_configurable = new com.gip.xyna.openapi.BooleanTypeValidator();
    validator_configurable.setName("configurable");
    validator_configurable.setValue(getConfigurable());
    result.getErrorMessages().addAll(validator_configurable.checkValid());
} catch (Exception e) {
    result.getErrorMessages().add("Error: could not validate CharacteristicSpecificationBase.configurable");
}

// validate CharacteristicSpecificationBase.description of type String
try {
    var validator_description = new com.gip.xyna.openapi.StringTypeValidator();
    validator_description.setName("description");
    validator_description.setValue(getDescription());
    result.getErrorMessages().addAll(validator_description.checkValid());
} catch (Exception e) {
    result.getErrorMessages().add("Error: could not validate CharacteristicSpecificationBase.description");
}

// validate CharacteristicSpecificationBase.extensible of type Boolean
try {
    var validator_extensible = new com.gip.xyna.openapi.BooleanTypeValidator();
    validator_extensible.setName("extensible");
    validator_extensible.setValue(getExtensible());
    result.getErrorMessages().addAll(validator_extensible.checkValid());
} catch (Exception e) {
    result.getErrorMessages().add("Error: could not validate CharacteristicSpecificationBase.extensible");
}

// validate CharacteristicSpecificationBase.isUnique of type Boolean
try {
    var validator_isUnique = new com.gip.xyna.openapi.BooleanTypeValidator();
    validator_isUnique.setName("isUnique");
    validator_isUnique.setValue(getIsUnique());
    result.getErrorMessages().addAll(validator_isUnique.checkValid());
} catch (Exception e) {
    result.getErrorMessages().add("Error: could not validate CharacteristicSpecificationBase.isUnique");
}

// validate CharacteristicSpecificationBase.maxCardinality of type Long
try {
    var validator_maxCardinality = new com.gip.xyna.openapi.NumberTypeValidator&lt;Long&gt;();
    validator_maxCardinality.setName("maxCardinality");
    validator_maxCardinality.setValue(getMaxCardinality());
    result.getErrorMessages().addAll(validator_maxCardinality.checkValid());
} catch (Exception e) {
    result.getErrorMessages().add("Error: could not validate CharacteristicSpecificationBase.maxCardinality");
}

// validate CharacteristicSpecificationBase.minCardinality of type Long
try {
    var validator_minCardinality = new com.gip.xyna.openapi.NumberTypeValidator&lt;Long&gt;();
    validator_minCardinality.setName("minCardinality");
    validator_minCardinality.setValue(getMinCardinality());
    result.getErrorMessages().addAll(validator_minCardinality.checkValid());
} catch (Exception e) {
    result.getErrorMessages().add("Error: could not validate CharacteristicSpecificationBase.minCardinality");
}

// validate CharacteristicSpecificationBase.name of type String
try {
    var validator_name = new com.gip.xyna.openapi.StringTypeValidator();
    validator_name.setName("name");
    validator_name.setValue(getName());
    result.getErrorMessages().addAll(validator_name.checkValid());
} catch (Exception e) {
    result.getErrorMessages().add("Error: could not validate CharacteristicSpecificationBase.name");
}

// validate CharacteristicSpecificationBase.regex of type String
try {
    var validator_regex = new com.gip.xyna.openapi.StringTypeValidator();
    validator_regex.setName("regex");
    validator_regex.setValue(getRegex());
    result.getErrorMessages().addAll(validator_regex.checkValid());
} catch (Exception e) {
    result.getErrorMessages().add("Error: could not validate CharacteristicSpecificationBase.regex");
}

// validate CharacteristicSpecificationBase.valueType of type String
try {
    var validator_valueType = new com.gip.xyna.openapi.StringTypeValidator();
    validator_valueType.setName("valueType");
    validator_valueType.setValue(getValueType());
    result.getErrorMessages().addAll(validator_valueType.checkValid());
} catch (Exception e) {
    result.getErrorMessages().add("Error: could not validate CharacteristicSpecificationBase.valueType");
}

// validate CharacteristicSpecificationBase.validFor of type TimePeriod
try {
    internalized.tmf633.datamodel.TimePeriod validFor = getValidFor();
    if (validFor != null) {
        result.getErrorMessages().addAll(validFor.validate().getErrorMessages());
    }
} catch (Exception e) {
    result.getErrorMessages().add("Error: could not validate CharacteristicSpecificationBase.validFor");
}

// validate CharacteristicSpecificationBase.atbaseType of type String
try {
    var validator_atbaseType = new com.gip.xyna.openapi.StringTypeValidator();
    validator_atbaseType.setName("@baseType");
    validator_atbaseType.setValue(getAtbaseType());
    result.getErrorMessages().addAll(validator_atbaseType.checkValid());
} catch (Exception e) {
    result.getErrorMessages().add("Error: could not validate CharacteristicSpecificationBase.atbaseType");
}

// validate CharacteristicSpecificationBase.atschemaLocation of type String
try {
    var validator_atschemaLocation = new com.gip.xyna.openapi.StringTypeValidator();
    validator_atschemaLocation.setName("@schemaLocation");
    validator_atschemaLocation.setValue(getAtschemaLocation());
    validator_atschemaLocation.setFormat("uri");
    result.getErrorMessages().addAll(validator_atschemaLocation.checkValid());
} catch (Exception e) {
    result.getErrorMessages().add("Error: could not validate CharacteristicSpecificationBase.atschemaLocation");
}

// validate CharacteristicSpecificationBase.attype of type String
try {
    var validator_attype = new com.gip.xyna.openapi.StringTypeValidator();
    validator_attype.setName("@type");
    validator_attype.setValue(getAttype());
    result.getErrorMessages().addAll(validator_attype.checkValid());
} catch (Exception e) {
    result.getErrorMessages().add("Error: could not validate CharacteristicSpecificationBase.attype");
}

// validate CharacteristicSpecificationBase.atvalueSchemaLocation of type String
try {
    var validator_atvalueSchemaLocation = new com.gip.xyna.openapi.StringTypeValidator();
    validator_atvalueSchemaLocation.setName("@valueSchemaLocation");
    validator_atvalueSchemaLocation.setValue(getAtvalueSchemaLocation());
    result.getErrorMessages().addAll(validator_atvalueSchemaLocation.checkValid());
} catch (Exception e) {
    result.getErrorMessages().add("Error: could not validate CharacteristicSpecificationBase.atvalueSchemaLocation");
}

return result.getResult();
                </CodeSnippet>
      </SourceCode>
    </Operation>
  </Service>
</DataType>
